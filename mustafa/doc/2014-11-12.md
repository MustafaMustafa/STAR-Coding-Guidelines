###Range-for statement:

C++ syntax is extended to support easier iteration over a list of elements. For example:  

[**Try it live.**](http://ideone.com/fRoN2j)  

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.C}
int main()
{

  vector<int> v {1,2,3,4,5};

  for(auto& i:v)  // reference to element
  {
    cout<<i<<endl;
    i +=1;        // modifies element value
  }

  for(auto i:v)   // copy of element
  {
    cout<<i<<endl;
  }
  return 0;
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Range-for statements work for any type where `begin()` and `end()` are defined and return iterators.  

The use of range-for loops increases code readability. However, programmers often need both, the elements 
of an iterable collection and its index. This is not directly supported in C++11.  

Unless optimized away by compiler, using copy of element could come at a performance cost if the element type is large.

**Recommendation:**  
-  Range-for loops are useful and should be allowed.   
-  Ordinary loops should be preferred when programmer needs the element index. Avoid having your own counter.  
-  Using reference to elements is encouraged when dealing with large objects.  


###Override controls: override
No explicit keyword in needed to to override a virtual function in C++03. In C++11, keyword `override` has been
added to make the programmer's intention explicit to the compiler and reader. For example:  

[**Try it live.**](http://ideone.com/JUgS5J)  

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.C}
struct B 
{
    virtual void a(int);
    virtual void f();
    virtual void g() const;
    void k(); // not virtual
    virtual void h(char);
};

struct D : B
{
    void a(float) override; // doesn't override B::a(int) (wrong signature)
    void f() override; // overrides B::f()
    void g() override; // doesn't override B::g() (wrong type)
    void k() override; // doesn't override B::k() (B::k() is not virtual)
    void h(char); // overrides B::h()
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Error given by gcc compiler when there is a problem with an override attempt is 
"error: ‘void foo::foo()’ marked override, but does not override".

The case of the `D::h(char)` is curious. gcc doesn't give a warning when the `override` keyword is not used.
This is likely to avoid a volcano of warnings when compiling older code. 

The `override` keyword is very useful. It makes the code more readable by making the programmer intention 
explicit and avoids potential problems by catching, otherwise silent errors, at compile time. 
Common bugs such as missing a function constatnness or being careless with function siganture when 
overriding can be avoided.

**Recommendation:**  
- Use of `override` keyword is encouraged.  

###Override controls: final
`final` keyword can be used to prevent inheriting from classes or simply preventing overriding methods in derived classe. For example:

[**Try it live**](http://ideone.com/EoJz91).  

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.C}
struct Base1 final { };
 
struct Derived1 : Base1 { }; // ill-formed because the class Base1 has been marked final

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.C}
struct Base2 
{
    virtual void f() final;
};
 
struct Derived2 : Base2 
{
    void f(); // ill-formed because the virtual function Base2::f has been marked final
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Using `final` closes the possibility of better implementation of functions in derived classes.  

**Recommendation:**
No recommendation.

###Control of defaults: default and delete
In C++11, the programmer can instruct the compiler not to create certain defaults by using the specifier `= delete`. 
This is particularly useful in two cases: 

1) Making objects non-copyable:  

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.C}
struct NonCopyable 
{
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete;
    NonCopyable & operator=(const NonCopyable&) = delete;
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

2) Preventing implicit conversion of function arguments:  

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.C}
struct NoInt 
{
    void f(double i);
    void f(int) = delete;
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

The specifier `= default` can be used to state the programmers intention:  

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.C}
struct SomeType 
{
    SomeType() = default; //The default constructor is explicitly stated.
    SomeType(OtherType value);
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

However, the verbosity here is redundant but it can be useful as a declaration of intention.  

For classes, the default generated functions are always public. Programmer can control the 
visibility of the defaults by using `= default`.

The current STAR guidelines state that "each class should have an assignment operator and a copy constructor" 
which forces programmers to implement their own copy functions even when they want the default behavior. 
The specifier `default` casts this guideline and avoids the pitfalls of implementing copy/assignment constructors
with default behavior.

**Recommendation:**  
The current STAR guideline should be changed to:  
- Each class should have an assignment operator and a copy constructor or defaults should explicitly requested. 
- Do not implement your own copy/assignment when member-wise copy is desired.  
- *Implement your own copy/assignment when class is a resource-handler or delete them.*  
- No guidance on other uses of `= delete`.  

###Control of defaults: move and copy:
In addition to constructors, control of defaults can be used for copy/move assignment operators or constructors and destructor.
However, one should pay attention to the [Rule of Five](http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29).
Stated roughly by Stroustrup:   

> If any move, copy, or destructor is explicitly specified (declared, defined, =default, or =delete) by the user, no move is generated by default. 
> If any move, copy, or destructor is explicitly specified (declared, defined, =default, or =delete) by the user, any undeclared copy operations 
> are generated by default, but this is deprecated, so don't rely on that.

This means that for backward compatibility STAR rule of mandating definition of copy assignment operator and constructor means that
move semantics will *not* be generated by default. This is good.  

Now if we maintain the STAR guideline on copy assignment/constructor it will be a good practice to ask programmers 
to be explicit about their desires for the move counterparts (that is if we eventually allow the move semantics).  

**Recommendation:**  
- Pay attention to the Rule of Five. Be explicit about your intentions for the move semantics.  


###References
Most of the examples in this document are modified versions of those in:   
- [C++11 wiki page](http://en.wikipedia.org/wiki/C%2B%2B11).   
- Stroustrup's [C++11 FAQ](http://www.stroustrup.com/C++11FAQ.html).
