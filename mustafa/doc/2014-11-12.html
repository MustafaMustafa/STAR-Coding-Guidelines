<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="Redirecting.css" type="text/css" />
</head>
<body>
<div id="TOC">
<h2 id="toctitle">Table of Contents:</h2>
<ul>
<li><a href="#range-for-statement">Range-for statement:</a></li>
<li><a href="#override-controls-override">Override controls: override</a></li>
<li><a href="#override-controls-final">Override controls: final</a></li>
<li><a href="#control-of-defaults-default-and-delete">Control of defaults: default and delete</a></li>
<li><a href="#control-of-defaults-move-and-copy">Control of defaults: move and copy:</a></li>
<li><a href="#references">References</a></li>
</ul>
<hr>
</div>
<h3 id="range-for-statement">Range-for statement:</h3>
<p>C++ syntax is extended to support easier iteration over a list of elements. For example:</p>
<p><a href="http://ideone.com/fRoN2j"><strong>Try it live.</strong></a></p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="dt">int</span> main()
{

  vector&lt;<span class="dt">int</span>&gt; v {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>};

  <span class="kw">for</span>(<span class="dt">auto</span>&amp; i:v)  <span class="co">// reference to element</span>
  {
    cout&lt;&lt;i&lt;&lt;endl;
    i +=<span class="dv">1</span>;        <span class="co">// modifies element value</span>
  }

  <span class="kw">for</span>(<span class="dt">auto</span> i:v)   <span class="co">// copy of element</span>
  {
    cout&lt;&lt;i&lt;&lt;endl;
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Range-for statements work for any type where <code>begin()</code> and <code>end()</code> are defined and return iterators.</p>
<p>The use of range-for loops increases code readability. However, programmers often need both, the elements of an iterable collection and its index. This is not directly supported in C++11.</p>
<p>Unless optimized away by compiler, using copy of element could come at a performance cost if the element type is large.</p>
<p><strong>Recommendation:</strong><br />- Range-for loops are useful and should be allowed.<br />- Ordinary loops should be preferred when programmer needs the element index. Avoid having your own counter.<br />- Using reference to elements is encouraged when dealing with large objects.</p>
<h3 id="override-controls-override">Override controls: override</h3>
<p>No explicit keyword in needed to to override a virtual function in C++03. In C++11, keyword <code>override</code> has been added to make the programmer's intention explicit to the compiler and reader. For example:</p>
<p><a href="http://ideone.com/JUgS5J"><strong>Try it live.</strong></a></p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> B 
{
    virtual <span class="dt">void</span> a(<span class="dt">int</span>);
    virtual <span class="dt">void</span> f();
    virtual <span class="dt">void</span> g() <span class="dt">const</span>;
    <span class="dt">void</span> k(); <span class="co">// not virtual</span>
    virtual <span class="dt">void</span> h(<span class="dt">char</span>);
};

<span class="kw">struct</span> D : B
{
    <span class="dt">void</span> a(<span class="dt">float</span>) override; <span class="co">// doesn&#39;t override B::a(int) (wrong signature)</span>
    <span class="dt">void</span> f() override; <span class="co">// overrides B::f()</span>
    <span class="dt">void</span> g() override; <span class="co">// doesn&#39;t override B::g() (wrong type)</span>
    <span class="dt">void</span> k() override; <span class="co">// doesn&#39;t override B::k() (B::k() is not virtual)</span>
    <span class="dt">void</span> h(<span class="dt">char</span>); <span class="co">// overrides B::h()</span>
};</code></pre>
<p>Error given by gcc compiler when there is a problem with an override attempt is &quot;error: ‘void foo::foo()’ marked override, but does not override&quot;.</p>
<p>The case of the <code>D::h(char)</code> is curious. gcc doesn't give a warning when the <code>override</code> keyword is not used. This is likely to avoid a volcano of warnings when compiling older code.</p>
<p>The <code>override</code> keyword is very useful. It makes the code more readable by making the programmer intention explicit and avoids potential problems by catching, otherwise silent errors, at compile time. Common bugs such as missing a function constatnness or being careless with function siganture when overriding can be avoided.</p>
<p><strong>Recommendation:</strong><br />- Use of <code>override</code> keyword is encouraged.</p>
<h3 id="override-controls-final">Override controls: final</h3>
<p><code>final</code> keyword can be used to prevent inheriting from classes or simply preventing overriding methods in derived classe. For example:</p>
<p><a href="http://ideone.com/EoJz91"><strong>Try it live</strong></a>.</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> Base1 final { };
 
<span class="kw">struct</span> Derived1 : Base1 { }; <span class="co">// ill-formed because the class Base1 has been marked final</span></code></pre>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> Base2 
{
    virtual <span class="dt">void</span> f() final;
};
 
<span class="kw">struct</span> Derived2 : Base2 
{
    <span class="dt">void</span> f(); <span class="co">// ill-formed because the virtual function Base2::f has been marked final</span>
};</code></pre>
<p>Using <code>final</code> closes the possibility of better implementation of functions in derived classes.</p>
<p><strong>Recommendation:</strong> No recommendation.</p>
<h3 id="control-of-defaults-default-and-delete">Control of defaults: default and delete</h3>
<p>In C++11, the programmer can instruct the compiler not to create certain defaults by using the specifier <code>= delete</code>. This is particularly useful in two cases:</p>
<ol style="list-style-type: decimal">
<li>Making objects non-copyable:</li>
</ol>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> NonCopyable 
{
    NonCopyable() = <span class="kw">default</span>;
    NonCopyable(<span class="dt">const</span> NonCopyable&amp;) = delete;
    NonCopyable &amp; operator=(<span class="dt">const</span> NonCopyable&amp;) = delete;
};</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Preventing implicit conversion of function arguments:</li>
</ol>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> NoInt 
{
    <span class="dt">void</span> f(<span class="dt">double</span> i);
    <span class="dt">void</span> f(<span class="dt">int</span>) = delete;
};</code></pre>
<p>The specifier <code>= default</code> can be used to state the programmers intention:</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> SomeType 
{
    SomeType() = <span class="kw">default</span>; <span class="co">//The default constructor is explicitly stated.</span>
    SomeType(OtherType value);
};</code></pre>
<p>However, the verbosity here is redundant but it can be useful as a declaration of intention.</p>
<p>For classes, the default generated functions are always public. Programmer can control the visibility of the defaults by using <code>= default</code>.</p>
<p>The current STAR guidelines state that &quot;each class should have an assignment operator and a copy constructor&quot; which forces programmers to implement their own copy functions even when they want the default behavior. The specifier <code>default</code> casts this guideline and avoids the pitfalls of implementing copy/assignment constructors with default behavior.</p>
<p><strong>Recommendation:</strong><br />The current STAR guideline should be changed to:<br />- Each class should have an assignment operator and a copy constructor or defaults should explicitly requested. - Do not implement your own copy/assignment when member-wise copy is desired.<br />- <em>Implement your own copy/assignment when class is a resource-handler or delete them.</em><br />- No guidance on other uses of <code>= delete</code>.</p>
<h3 id="control-of-defaults-move-and-copy">Control of defaults: move and copy:</h3>
<p>In addition to constructors, control of defaults can be used for copy/move assignment operators or constructors and destructor. However, one should pay attention to the <a href="http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29">Rule of Five</a>. Stated roughly by Stroustrup:</p>
<blockquote>
<p>If any move, copy, or destructor is explicitly specified (declared, defined, =default, or =delete) by the user, no move is generated by default. If any move, copy, or destructor is explicitly specified (declared, defined, =default, or =delete) by the user, any undeclared copy operations are generated by default, but this is deprecated, so don't rely on that.</p>
</blockquote>
<p>This means that for backward compatibility STAR rule of mandating definition of copy assignment operator and constructor means that move semantics will <em>not</em> be generated by default. This is good.</p>
<p>Now if we maintain the STAR guideline on copy assignment/constructor it will be a good practice to ask programmers to be explicit about their desires for the move counterparts (that is if we eventually allow the move semantics).</p>
<p><strong>Recommendation:</strong><br />- Pay attention to the Rule of Five. Be explicit about your intentions for the move semantics.</p>
<h3 id="references">References</h3>
<p>Most of the examples in this document are modified versions of those in:<br />- <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11 wiki page</a>.<br />- Stroustrup's <a href="http://www.stroustrup.com/C++11FAQ.html">C++11 FAQ</a>.</p>
</body>
</html>
