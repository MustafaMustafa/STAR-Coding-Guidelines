<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="Redirecting.css" type="text/css" />
</head>
<body>
<div id="TOC">
<h2 id="toctitle">Table of Contents:</h2>
<ul>
<li><a href="#range-for-statement">Range-for statement:</a></li>
<li><a href="#override-controls-override">Override controls: override</a></li>
<li><a href="#override-controls-final">Override controls: final</a></li>
<li><a href="#control-of-defaults-default-and-delete">Control of defaults: default and delete</a></li>
<li><a href="#control-of-defaults-move-and-copy">Control of defaults: move and copy:</a></li>
<li><a href="#in-class-member-initializers">In-class member initializers</a></li>
<li><a href="#rvo-and-copy-elision">RVO and copy elision</a></li>
<li><a href="#rvalue-reference-and-move-semantics">Rvalue reference and move semantics</a></li>
<li><a href="#smart-pointers">Smart pointers</a></li>
<li><a href="#references">References</a></li>
</ul>
<hr>
</div>
<h3 id="range-for-statement">Range-for statement:</h3>
<p>C++ syntax is extended to support easier iteration over a list of elements. For example:</p>
<p><a href="http://ideone.com/fRoN2j"><strong>Try it live.</strong></a></p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="dt">int</span> main()
{

  vector&lt;<span class="dt">int</span>&gt; v {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>};

  <span class="kw">for</span>(<span class="dt">auto</span>&amp; i:v)  <span class="co">// reference to element</span>
  {
    cout&lt;&lt;i&lt;&lt;endl;
    i +=<span class="dv">1</span>;        <span class="co">// modifies element value</span>
  }

  <span class="kw">for</span>(<span class="dt">auto</span> i:v)   <span class="co">// copy of element</span>
  {
    cout&lt;&lt;i&lt;&lt;endl;
  }
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Range-for statements work for any type where <code>begin()</code> and <code>end()</code> are defined and return iterators.</p>
<p>The use of range-for loops increases code readability. However, programmers often need both, the elements of an iterable collection and its index. This is not directly supported in C++11.</p>
<p>Unless optimized away by compiler, using a copy of element could come at a performance cost if the element type is large.</p>
<p><strong>Recommendation:</strong><br />- Range-for loops are useful and should be allowed.<br />- Ordinary loops should be preferred when programmer needs the element index. Avoid having your own counter.<br />- Using reference to elements is encouraged when dealing with large objects. Use <code>const</code> reference when you don't need to modify the object state.</p>
<h3 id="override-controls-override">Override controls: override</h3>
<p>No explicit keyword is needed to to override a virtual function in C++03. In C++11, keyword <code>override</code> has been added to make the programmer's intention explicit to the compiler and reader. For example:</p>
<p><a href="http://ideone.com/JUgS5J"><strong>Try it live.</strong></a></p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> B 
{
    virtual <span class="dt">void</span> a(<span class="dt">int</span>);
    virtual <span class="dt">void</span> f();
    virtual <span class="dt">void</span> g() <span class="dt">const</span>;
    <span class="dt">void</span> k(); <span class="co">// not virtual</span>
    virtual <span class="dt">void</span> h(<span class="dt">char</span>);
};

<span class="kw">struct</span> D : B
{
    <span class="dt">void</span> a(<span class="dt">float</span>) override; <span class="co">// doesn&#39;t override B::a(int) (wrong signature)</span>
    <span class="dt">void</span> f() override; <span class="co">// overrides B::f()</span>
    <span class="dt">void</span> g() override; <span class="co">// doesn&#39;t override B::g() (wrong type)</span>
    <span class="dt">void</span> k() override; <span class="co">// doesn&#39;t override B::k() (B::k() is not virtual)</span>
    <span class="dt">void</span> h(<span class="dt">char</span>); <span class="co">// overrides B::h()</span>
};</code></pre>
<p>Error given by gcc compiler when there is a problem with an override attempt is</p>
<pre class="sourceCode C"><code class="sourceCode c">error: ‘void foo::foo()’ marked override, but does not override.</code></pre>
<p>The case of the <code>D::h(char)</code> is curious. gcc doesn't give a warning when the <code>override</code> keyword is not used. This is likely to avoid a volcano of warnings when compiling older code.</p>
<p>The <code>override</code> keyword is very useful. It makes the code more readable by making the programmer intention explicit and avoids potential problems by catching, otherwise silent errors, at compile time. Common bugs such as missing a function constatnness or being careless with function siganture when overriding can be avoided.</p>
<p><strong>Recommendation:</strong><br />- Use of <code>override</code> keyword is encouraged.</p>
<h3 id="override-controls-final">Override controls: final</h3>
<p><code>final</code> keyword can be used to prevent inheriting from classes or simply preventing overriding methods in derived classe. For example:</p>
<p><a href="http://ideone.com/EoJz91"><strong>Try it live</strong></a>.</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> Base1 final { };
 
<span class="kw">struct</span> Derived1 : Base1 { }; <span class="co">// ill-formed because the class Base1 has been marked final</span></code></pre>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> Base2 
{
    virtual <span class="dt">void</span> f() final;
};
 
<span class="kw">struct</span> Derived2 : Base2 
{
    <span class="dt">void</span> f(); <span class="co">// ill-formed because the virtual function Base2::f has been marked final</span>
};</code></pre>
<p>Using <code>final</code> closes the possibility of better implementation of functions in derived classes.</p>
<p><strong>Recommendation:</strong> No recommendation.</p>
<h3 id="control-of-defaults-default-and-delete">Control of defaults: default and delete</h3>
<p>In C++11, the programmer can instruct the compiler not to create certain defaults by using the specifier <code>= delete</code>. This is particularly useful in two cases:</p>
<ol style="list-style-type: decimal">
<li>Making objects non-copyable:</li>
</ol>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> NonCopyable 
{
    NonCopyable() = <span class="kw">default</span>;
    NonCopyable(<span class="dt">const</span> NonCopyable&amp;) = delete;
    NonCopyable &amp; operator=(<span class="dt">const</span> NonCopyable&amp;) = delete;
};</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Preventing implicit conversion of function arguments:</li>
</ol>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> NoInt 
{
    <span class="dt">void</span> f(<span class="dt">double</span> i);
    <span class="dt">void</span> f(<span class="dt">int</span>) = delete;
};</code></pre>
<p>The specifier <code>= default</code> can be used to state the programmers intention:</p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="kw">struct</span> SomeType 
{
    SomeType() = <span class="kw">default</span>; <span class="co">//The default constructor is explicitly stated.</span>
    SomeType(OtherType value);
};</code></pre>
<p>However, the verbosity here is redundant, it is useful as a declaration of intention.</p>
<p>For classes, the default generated functions are always public. Programmer can control the visibility of the defaults by using <code>= default</code>.</p>
<p>The current STAR guidelines state that &quot;each class should have an assignment operator and a copy constructor&quot; which forces programmers to implement their own copy functions even when they want the default behavior. The specifier <code>default</code> casts this guideline and avoids the pitfalls of implementing copy/assignment constructors with default behavior.</p>
<p><strong>Recommendation:</strong><br />The current STAR guideline should be changed to:<br />- Each class should have an assignment operator and a copy constructor or defaults should be explicitly requested.<br />- Do not implement your own copy/assignment when member-wise copy is desired.<br />- <em>Implement your own copy/assignment when class is a resource-handler or delete them.</em><br />- No guidance on other uses of <code>= delete</code>.</p>
<h3 id="control-of-defaults-move-and-copy">Control of defaults: move and copy:</h3>
<p>In addition to constructors, control of defaults can be used for copy/move assignment operators or constructors and destructor. However, one should pay attention to the <a href="http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29">Rule of Five</a>. Stated roughly by Stroustrup:</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>If any move, copy, or destructor is explicitly specified (declared, defined, =default, or =delete) by the user, no move is generated by default.<br /></li>
<li>If any move, copy, or destructor is explicitly specified (declared, defined, =default, or =delete) by the user, any undeclared copy operations are generated by default, but this is deprecated, so don't rely on that.</li>
</ol>
</blockquote>
<p>This means that for backward compatibility STAR rule of mandating definition of copy assignment operator and constructor means that move semantics will <em>not</em> be generated by default. This is good.</p>
<p>Now, if we maintain the STAR guideline on copy assignment/constructor it will be a good practice to ask programmers to be explicit about their desires for the move counterparts (that is if we eventually allow the move semantics).</p>
<p><strong>Recommendation:</strong><br />- Pay attention to the Rule of Five.<br />- Be explicit about your intentions for the move semantics.</p>
<h3 id="in-class-member-initializers">In-class member initializers</h3>
<p>C++98 allows in-class member initialization for static members only. C++11 allows in-class member initialization for any variable. For example:</p>
<pre class="sourceCode C"><code class="sourceCode c">Class foo
{
  public:
    <span class="dt">int</span> x = <span class="dv">1</span>;
}</code></pre>
<p>This is basically equivalent to using initialization lists in constructors. The advantage of in-class initialization is that it allows consistent default initialization when there are multiple constructors and saves a lot of typing resulting in cleaner codes.</p>
<p>Constructor initialization overrides in-class initialization.</p>
<p><strong>Recommendation:</strong><br />- In-class member initialization should be encouraged.</p>
<h3 id="rvo-and-copy-elision">RVO and copy elision</h3>
<p>This is a note that will become useful later.<br />Return value optimization (RVO) and copy elision are both implemented in gcc compiler.<br />The copy elision as an implementation of the <em>as-if</em> rule of the standard which states that a compiler is allowed to do optimization to avoid unnecessary copying if the behavior of the program is the same <em>as if</em> all the requirements of the standard has been fulfilled. Furthermore,</p>
<blockquote>
<p>The term return value optimization refers to a special clause in the C++ standard which goes even further than the &quot;as-if&quot; rule: an implementation may omit a copy operation resulting from a return statement, even if the copy constructor has side effects.</p>
</blockquote>
<p>Example:</p>
<p><a href="http://ideone.com/yOnDk2"><strong>Try it live.</strong></a></p>
<pre class="sourceCode C"><code class="sourceCode c"><span class="ot">#include &lt;iostream&gt;</span>
 
<span class="kw">struct</span> C 
{
  C() {}
  C(<span class="dt">const</span> C&amp;) { std::cout &lt;&lt; <span class="st">&quot;A copy was made.</span><span class="ch">\n</span><span class="st">&quot;</span>; }
};
 
C f() {
  <span class="kw">return</span> C();
}
 
<span class="dt">int</span> main()
{
  std::cout &lt;&lt; <span class="st">&quot;Hello World!</span><span class="ch">\n</span><span class="st">&quot;</span>;
  C obj = f();
}</code></pre>
<p>Compiling and running with gcc gives:</p>
<pre class="sourceCode C"><code class="sourceCode c">Hello World!</code></pre>
<p>So both copies (from local variable to the stack and from the stack to obj) have been optimized away. i.e. RVO is being used even though avoiding the copy constructor has side effect.</p>
<p>You can avoid this optimization by using the gcc flag <code>-fno-elide-constructors</code>.</p>
<h3 id="rvalue-reference-and-move-semantics">Rvalue reference and move semantics</h3>
<p><font color='red'> This section will be completed later.</font><br />Rvalue reference are powerful to enable two things: 1) move semantics and 2) perfect forwarding.</p>
<p>Recommended <a href="http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">article</a> for our forthcoming discussion.</p>
<h3 id="smart-pointers">Smart pointers</h3>
<p><font color='red'> To be completed.</font></p>
<h3 id="references">References</h3>
<p>Most of the examples in this document are modified versions of those in:<br />- <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11 wiki page</a>.<br />- Stroustrup's <a href="http://www.stroustrup.com/C++11FAQ.html">C++11 FAQ</a>.</p>
</body>
</html>
